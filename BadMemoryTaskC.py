"""
                Задачка: Скверная Память
Zart PMP вышел в финал мирового чемпионата ICPC World Finals, который проводится в китайском городе Харбине.
Сходив на групповую экскурсию в Sun Island Park и насладившись выставкой снежных скульптур, PMP должен вернуться
к автобусам до того, как они уедут. Но парк очень большой, и он не знает, как найти стоянку. В парке есть
n перекрестков, пронумерованных от 1 до n. Есть m двунаправленных дорог, соединяющих некоторые пары из этих
перекрестков. На k перекрестках волонтеры ICPC помогают командам и показывают им путь к месту назначения.
Волонтеры стоят в фиксированных точках и не двигаются, никакие два волонтера не стоят на одном перекрестке.
Когда PMP просит волонтера указать путь до стоянки, тот/та может описать ему весь путь. Но парк полностью
покрыт льдом и снегом и все выглядит почти одинаково. Из-за этого PMP может запомнить не более q перекрестков
после каждого вопроса (не считая перекрестка, на котором он стоит в данный момент). Он всегда рассказывает волонтерам
о своей слабой памяти и если нет прямого пути длиной не более q (в количестве дорог), ведущему к стоянке, то волонтер
направит PMP к другому волонтеру (расстояние до которого в количестве дорог, разумеется, не должно превышать q).
Волонтеры ICPC прекрасно знают парк и всегда указывают PMP самый лучший путь. Таким образом, если существует путь
до стоянки, PMP безусловно найдет его. Изначально PMP находится на перекрестке s, а автобусы стоят на перекрестке t.
На перекрестке s всегда есть волонтер. Ваша задача — найти, при каком минимальном значении q PMP сможет найти автобусы.
Входные данные:
    В первой строке записаны через пробел три целых числа n,m,k — количество перекрестков, дорог и волонтеров.
В следующей строке записано через пробел k различных целых чисел от 1 до n включительно — номера перекрестков,
на которых стоят волонтеры. Следующие m строк описывают дороги. В i-ой строке записаны через пробел два целых числа
ui,vi (1≤ui,vi≤n,ui≠vi) — два перекрестка, соединенные i-ой дорогой. Между любыми двумя перекрестками есть не
более одной дороги. Последняя строка входного файла содержит через пробел два целых числа s,t (1≤s,t≤n,s≠t) —
исходная позиция PMP, расположение автобусов. Не гарантируется, что автобусная станция достижима по дорогам парка из
перекрестка с номером s. Гарантируется, что на перекрестке s всегда стоит волонтер.
Выходные данные:
    Выведите на единственной строке ответ к задаче: минимальное значении q, при котором PMP сможет найти автобусы.
Если PMP не сможет найти автобусы ни при каком значении q выведите -1.
"""
listVolunteers = []  # список волонтеров
graph = dict()  # дороги
color = list() #0-white 1-grey 2-black


class Stack:
    def __init__(self):
        self.stack = []

    def push(self, item):
        self.stack.append(item)

    def pop(self):
        if len(self.stack) == 0:
            return None
        removed = self.stack.pop()
        return removed

    def peek(self):
        if len(self.stack) == 0:
            return None
        else:
            return self.stack[len(self.stack) - 1]

    def isNull(self):
        if len(self.stack) == 0:
            return True
        else:
            return False


def dfs(s: int, t: int, visited=None):
    color[s-1] = 1
    for next in graph[s]:
        if color[next-1] == 0:
            color[s - 1] = 2
            dfs(next, t)
        if color[next-1] == 2:
            print(next)

    return visited


def runSolution():
    """Считывание данных"""
    mas = input().split(" ")
    n = int(mas[0])  # кол-во перекрестков
    m = int(mas[1])  # кол-во дорог
    k = int(mas[2])  # кол-во волонтеров

    mas = input().split(" ")
    for i in range(0, k):
        listVolunteers.append(int(mas[i]))

    for i in range(0, m):
        mas = input().split(" ")
        color.append(0)
        a1 = int(mas[0])
        a2 = int(mas[1])
        if a1 not in graph:
            graph[a1] = {a2}
        else:
            graph[a1].add(a2)

    mas = input().split(" ")
    s = int(mas[0])  # исходная позиция PMP
    t = int(mas[1])  # расположение автобусов

    # обход графа
    #listPath = dfs(s=s, t=t)
    visited = set()
    dfs(visited, graph, s, t)

    #print("Граф: ", graph)
    #print("Волонтеры: ", listVolunteers)
    #print("Возможные пути: ")
    #print([el for el in listPath])
    return


if __name__ == '__main__':
    runSolution()

"""
6 6 3
1 3 6
1 2
2 3
4 2
5 6
4 5
3 4
1 6
Answer - 3

6 5 3
1 5 6
1 2
2 3
3 4
4 5
6 3
1 5
Answer - 3
"""
